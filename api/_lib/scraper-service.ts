
import { GoogleGenAI, Type } from "@google/genai";
import { readSheetData, findAndUpsertRow } from './sheets-service';
import { supabase, upsertSupabaseData } from './supabase-service';

declare var process: any;
const AFFILIATE_TAG = 'tag=malayalambooks-21';

function getAi() {
    const key = process.env.API_KEY || process.env.GOOGLE_API_KEY;
    if (!key || key.trim() === "") throw new Error("API_KEY missing.");
    return new GoogleGenAI({ apiKey: key.trim() });
}

function createNumericHash(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return Math.abs(hash);
}

const ensureArray = (raw: any): string[] => {
    if (!raw) return [];
    if (Array.isArray(raw)) return raw.map(String);
    try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed.map(String) : [String(raw)];
    } catch {
        return [String(raw)];
    }
};

const APPROVED_SUBJECTS = [
    "Arts, Culture & Sports", "Biology / Life Science", "Chemistry", "Computer Science / IT / Cyber Laws",
    "Current Affairs", "Educational Psychology / Pedagogy", "Electrical Engineering", "English",
    "Environment", "General Knowledge", "General Knowledge / Static GK", "General Science / Science & Tech",
    "Indian Economy", "Indian Geography", "Indian History", "Indian Polity / Constitution",
    "Kerala Geography", "Kerala History", "Kerala History / Renaissance", "Kerala Specific GK",
    "Malayalam", "Nursing Science / Health Care", "Physics", "Quantitative Aptitude",
    "Reasoning / Mental Ability", "Social Science / Sociology"
];

/**
 * BULK UPLOAD LOGIC: Handles manual entries
 */
export async function bulkUploadQuestions(questions: any[]) {
    if (!supabase) throw new Error("Supabase required.");
    if (!questions.length) return { message: "No questions provided." };

    const { data: maxIdRow } = await supabase.from('questionbank').select('id').order('id', { ascending: false }).limit(1).single();
    let currentId = (maxIdRow?.id || 50000) + 1;

    const sanitized = questions.map(q => ({
        id: q.id || currentId++,
        topic: q.topic || 'General',
        question: q.question,
        options: ensureArray(q.options),
        correct_answer_index: parseInt(String(q.correct_answer_index || q.correctAnswerIndex || 1)),
        subject: q.subject || 'General Knowledge',
        difficulty: q.difficulty || 'PSC Level',
        explanation: q.explanation || ''
    }));

    await upsertSupabaseData('questionbank', sanitized);
    for (const q of sanitized) {
        await findAndUpsertRow('QuestionBank', String(q.id), [q.id, q.topic, q.question, JSON.stringify(q.options), q.correct_answer_index, q.subject, q.difficulty, q.explanation]);
    }
    return { message: `Successfully uploaded ${sanitized.length} questions.` };
}

/**
 * BACKFILL LOGIC: Repairs questions missing explanations
 */
export async function backfillExplanations() {
    if (!supabase) throw new Error("Supabase required.");
    const { data: missing, error } = await supabase.from('questionbank').select('*').or('explanation.is.null,explanation.eq.""').limit(15);
    if (error) throw error;
    if (!missing || missing.length === 0) return { message: "All questions already have explanations." };

    try {
        const ai = getAi();
        const response = await ai.models.generateContent({
            model: 'gemini-3-flash-preview',
            contents: `Generate high-quality Kerala PSC explanations (in Malayalam) for these questions. Data: ${JSON.stringify(missing)}`,
            config: { responseMimeType: "application/json" }
        });
        const updates = JSON.parse(response.text || "[]");
        if (updates.length > 0) {
            const finalData = missing.map(q => ({ ...q, explanation: updates.find((u: any) => u.id == q.id)?.explanation || q.explanation }));
            await upsertSupabaseData('questionbank', finalData);
            for (const q of finalData) await findAndUpsertRow('QuestionBank', String(q.id), [q.id, q.topic, q.question, JSON.stringify(q.options), q.correct_answer_index, q.subject, q.difficulty, q.explanation]);
            return { message: `Successfully added explanations to ${finalData.length} questions.` };
        }
    } catch (e: any) { throw e; }
    return { message: "Explanation repair batch failed." };
}

/**
 * GENERATION LOGIC: Mirror to Sheets added
 */
export async function generateQuestionsForGaps(batchSizeOrTopic: number | string = 5) {
    if (!supabase) throw new Error("Supabase required.");
    let targetMappings: { topic: string, subject: string }[] = [];

    if (typeof batchSizeOrTopic === 'string') {
        const { data: mappings } = await supabase.from('syllabus').select('topic, subject, title, id').or(`topic.ilike.%${batchSizeOrTopic}%,title.ilike.%${batchSizeOrTopic}%,id.eq.${batchSizeOrTopic}`).limit(1);
        if (mappings?.[0]) targetMappings = [{ topic: mappings[0].topic || mappings[0].title || batchSizeOrTopic, subject: mappings[0].subject || 'General Knowledge' }];
        else throw new Error(`Area "${batchSizeOrTopic}" not found.`);
    } else {
        const { data: sData } = await supabase.from('syllabus').select('topic, subject, title');
        if (!sData?.length) return { message: "No syllabus found." };
        const { data: qData } = await supabase.from('questionbank').select('topic');
        const counts: Record<string, number> = {};
        qData?.forEach(q => { const t = String(q.topic || '').toLowerCase().trim(); if (t) counts[t] = (counts[t] || 0) + 1; });
        targetMappings = sData.map(s => ({ topic: s.topic || s.title, subject: s.subject || 'General Knowledge', count: counts[String(s.topic || s.title).toLowerCase().trim()] || 0 })).sort((a, b) => a.count - b.count).slice(0, batchSizeOrTopic as number);
    }

    try {
        const ai = getAi();
        const response = await ai.models.generateContent({
            model: 'gemini-3-flash-preview', 
            contents: `Generate 5 Kerala PSC MCQs for: ${targetMappings.map(m => `${m.subject} -> ${m.topic}`).join(', ')}.
            
            CRITICAL: Subject field MUST be exactly one from this list:
            [${APPROVED_SUBJECTS.join(', ')}]
            
            JSON format: { "topic": "string", "subject": "string", "question": "string", "options": ["A","B","C","D"], "correctAnswerIndex": 1-4, "explanation": "string" }`,
            config: { responseMimeType: "application/json" }
        });
        const items = JSON.parse(response.text || "[]");
        if (items.length > 0) {
            const { data: maxIdRow } = await supabase.from('questionbank').select('id').order('id', { ascending: false }).limit(1).single();
            let currentId = (maxIdRow?.id || 50000) + 1;
            const sbData = items.map((item: any) => ({
                id: currentId++, topic: item.topic, question: item.question, options: ensureArray(item.options), 
                correct_answer_index: parseInt(String(item.correctAnswerIndex || 1)), subject: item.subject, 
                difficulty: 'PSC Level', explanation: item.explanation || ''
            }));
            await upsertSupabaseData('questionbank', sbData);
            for (const q of sbData) await findAndUpsertRow('QuestionBank', String(q.id), [q.id, q.topic, q.question, JSON.stringify(q.options), q.correct_answer_index, q.subject, q.difficulty, q.explanation]);
            return { message: `Generated ${sbData.length} questions.` };
        }
    } catch (e: any) { throw e; }
    return { message: "No questions generated." };
}

export async function runDailyUpdateScrapers() {
    await Promise.all([scrapeKpscNotifications(), scrapePscLiveUpdates(), scrapeCurrentAffairs(), scrapeGkFacts()]);
    await generateQuestionsForGaps(5);
    return { message: "Daily Update Routine Finished." };
}

export async function scrapeGkFacts() {
    try {
        const ai = getAi();
        const response = await ai.models.generateContent({
            model: "gemini-3-flash-preview",
            contents: "10 Malayalam PSC facts. JSON: {fact, category}",
            config: { responseMimeType: "application/json" }
        });
        const items = JSON.parse(response.text || "[]");
        if (items.length > 0) {
            const sbData = items.map((it: any) => ({ id: createNumericHash(it.fact), fact: it.fact, category: it.category }));
            await upsertSupabaseData('gk', sbData);
            for (const it of sbData) await findAndUpsertRow('GK', String(it.id), [it.id, it.fact, it.category]);
        }
    } catch (e: any) { throw e; }
}

export async function scrapeCurrentAffairs() {
    try {
        const ai = getAi();
        const response = await ai.models.generateContent({
            model: "gemini-3-flash-preview",
            contents: "10 Latest CA items for Kerala. JSON: {title, source, date}",
            config: { tools: [{ googleSearch: {} }], responseMimeType: "application/json" }
        });
        const items = JSON.parse(response.text || "[]");
        if (items.length > 0) {
            const sbData = items.map((it: any) => ({ id: createNumericHash(it.title), title: it.title, source: it.source, date: it.date }));
            await upsertSupabaseData('currentaffairs', sbData);
            for (const it of sbData) await findAndUpsertRow('CurrentAffairs', String(it.id), [it.id, it.title, it.source, it.date]);
        }
    } catch (e: any) { throw e; }
}

export async function scrapeKpscNotifications() {
    try {
        const ai = getAi();
        const response = await ai.models.generateContent({
            model: "gemini-3-flash-preview",
            contents: `5 newest jobs from keralapsc.gov.in. JSON: title, categoryNumber, lastDate, link`,
            config: { tools: [{ googleSearch: {} }], responseMimeType: "application/json" }
        });
        const items = JSON.parse(response.text || "[]");
        if (items.length > 0) {
            const sbData = items.map((it: any) => ({ ...it, id: createNumericHash(it.categoryNumber || it.title) }));
            await upsertSupabaseData('notifications', sbData);
            for (const it of sbData) await findAndUpsertRow('Notifications', String(it.id), [it.id, it.title, it.categoryNumber, it.lastDate, it.link]);
        }
    } catch (e: any) { throw e; }
}

export async function scrapePscLiveUpdates() {
    try {
        const ai = getAi();
        const response = await ai.models.generateContent({
            model: 'gemini-3-flash-preview',
            contents: `5 results from keralapsc.gov.in. JSON: title, url, section, published_date`,
            config: { tools: [{ googleSearch: {} }], responseMimeType: "application/json" }
        });
        const items = JSON.parse(response.text || "[]");
        if (items.length > 0) {
            const sbData = items.map((it: any) => ({ id: createNumericHash(it.url || it.title), title: it.title, url: it.url, section: it.section, published_date: it.published_date }));
            await upsertSupabaseData('liveupdates', sbData);
            for (const it of sbData) await findAndUpsertRow('LiveUpdates', String(it.id), [it.title, it.url, it.section, it.published_date]);
        }
    } catch (e: any) { throw e; }
}

export async function runBookScraper() {
    try {
        const ai = getAi();
        const response = await ai.models.generateContent({
            model: "gemini-3-flash-preview", 
            contents: `8 PSC guides on Amazon.in. JSON: title, author, asin, amazonLink`,
            config: { tools: [{ googleSearch: {} }], responseMimeType: "application/json" }
        });
        const items = JSON.parse(response.text || "[]");
        if (items.length > 0) {
            const finalItems = items.map((it: any) => ({ 
                id: it.asin || createNumericHash(it.title),
                title: it.title, author: it.author, 
                imageUrl: it.asin ? `https://images-na.ssl-images-amazon.com/images/P/${it.asin.toUpperCase()}.01._SCLZZZZZZZ_SX400_.jpg` : "", 
                amazonLink: it.amazonLink + (it.amazonLink.includes('?') ? '&' : '?') + AFFILIATE_TAG 
            }));
            await upsertSupabaseData('bookstore', finalItems);
            for (const it of finalItems) await findAndUpsertRow('Bookstore', String(it.id), [it.id, it.title, it.author, it.imageUrl, it.amazonLink]);
        }
    } catch (e: any) { throw e; }
}

export async function repairLanguageMismatches() {
    if (!supabase) throw new Error("Supabase required.");
    const technicalSubjects = ['English', 'Engineering', 'IT', 'Computer Science', 'Technical', 'Nursing'];
    const { data: mismatches } = await supabase.from('questionbank').select('*').in('subject', technicalSubjects).limit(30);
    if (!mismatches || mismatches.length === 0) return { message: "No mismatches found." };

    try {
        const ai = getAi();
        const response = await ai.models.generateContent({
            model: "gemini-3-flash-preview",
            contents: `Restore these questions to ENGLISH: ${JSON.stringify(mismatches)}`,
            config: { responseMimeType: "application/json" }
        });
        const repaired = JSON.parse(response.text || "[]");
        if (repaired.length > 0) {
            await upsertSupabaseData('questionbank', repaired);
            for (const q of repaired) {
                await findAndUpsertRow('QuestionBank', String(q.id), [q.id, q.topic, q.question, JSON.stringify(q.options), q.correct_answer_index, q.subject, q.difficulty, q.explanation]);
            }
        }
    } catch (e: any) { throw e; }
    return { message: "Language repair batch finished." };
}

export async function syncAllFromSheetsToSupabase() {
    if (!supabase) throw new Error("No Supabase.");
    const tables = [
        { sheet: 'Exams', supabase: 'exams', map: (r: any[]) => ({ id: r[0], title_ml: r[1], title_en: r[2], description_ml: r[3], description_en: r[4], category: r[5], level: r[6], icon_type: r[7] }) },
        { sheet: 'Syllabus', supabase: 'syllabus', map: (r: any[]) => ({ id: r[0], exam_id: r[1], title: r[2], questions: parseInt(r[3] || '0'), duration: parseInt(r[4] || '0'), subject: r[5], topic: r[6] }) },
        { sheet: 'QuestionBank', supabase: 'questionbank', map: (r: any[]) => ({ id: parseInt(r[0]), topic: r[1], question: r[2], options: ensureArray(r[3]), correct_answer_index: parseInt(r[4] || '1'), subject: r[5], difficulty: r[6], explanation: r[7] }) }
    ];
    for (const t of tables) {
        const rows = await readSheetData(`${t.sheet}!A2:Z`);
        if (rows?.length) {
            const mappedData = rows.filter(r => r[0]).map(t.map as any);
            await upsertSupabaseData(t.supabase, mappedData);
        }
    }
    return { message: "Sync complete." };
}
